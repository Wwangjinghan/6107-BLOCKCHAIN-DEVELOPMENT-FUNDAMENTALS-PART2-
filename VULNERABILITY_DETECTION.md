# Vulnerability Detection Module

This module provides comprehensive vulnerability detection for Hardhat-local EVM transaction analysis, combining dynamic trace analysis with optional static analysis tools.

## Overview

The vulnerability detection system consists of three components:

1. **`scripts/vuln_detect.js`** - Dynamic trace-based vulnerability detection
2. **`scripts/static_scan.js`** - Static analysis integration (Slither & Mythril)
3. **Integration** - Optional embedding of findings in trace analysis

## Detected Vulnerabilities

### 1. Reentrancy (HIGH SEVERITY)

**Heuristic**: Detects pattern where external CALL/DELEGATECALL is followed by SSTORE at same or outer depth within 500 steps.

**Evidence Provided**:
- Call step and opcode
- SSTORE step
- Depth transitions
- Steps between call and state update

**Example**:
```javascript
// Pattern flagged: State update after external call
external CALL at step 42 ‚Üí SSTORE at step 85
```

**Recommendation**: Use checks-effects-interactions pattern, emit events before calls, apply reentrancy guards.

---

### 2. Unchecked External Calls (MEDIUM SEVERITY)

**Heuristic**: Flags external calls (CALL, STATICCALL, DELEGATECALL, CALLCODE) where return value is not checked with ISZERO/JUMPI/REVERT within 20 steps.

**Evidence Provided**:
- Call step and opcode
- Program counter
- Whether check was found
- Search window size

**Example**:
```javascript
// Pattern flagged: No return value check
CALL at step 15 ‚Üí no ISZERO/JUMPI found in next 20 steps
```

**Recommendation**: Always check external call return values using require() or explicit error handling.

---

### 3. Access Control Issues

#### 3a. Use of tx.origin (HIGH SEVERITY)

**Heuristic**: Detects presence of ORIGIN opcode usage.

**Why It's Dangerous**: tx.origin can be exploited through delegatecall chains; msg.sender should be used instead.

**Evidence**: Step and PC of ORIGIN opcode usage.

---

#### 3b. Risky DELEGATECALL (MEDIUM SEVERITY)

**Heuristic**: Flags all DELEGATECALL usage.

**Why It's Risky**: DELEGATECALL executes target code in caller's context, risking unauthorized state changes.

**Evidence**: Step, PC, and count of DELEGATECALL operations.

**Recommendation**: Ensure target addresses are constant and whitelisted.

---

### 4. Overflow/Underflow (MEDIUM SEVERITY)

**Dynamic Heuristic**:
- Flags arithmetic operations (ADD, SUB, MUL) followed by INVALID or REVERT within 5 steps
- Indicates Solidity >=0.8 overflow checking or SafeMath library triggering

**Note**: Solidity >=0.8 has built-in overflow checks. Trace evidence shows when checks are triggered.

**Evidence Provided**:
- Arithmetic operation step and type
- Failure step (INVALID/REVERT)
- Distance between operations

---

## Usage

### Quick Start

```bash
# 1. Generate trace
node scripts/trace.js

# 2. Parse trace and run vulnerability detection
node scripts/parse_trace.js --detect-vulns

# 3. View findings.json
cat findings.json
```

### Embed Findings in Parsed Trace

```bash
node scripts/parse_trace.js --detect-vulns --embed-findings

# Findings will be added to parsed_trace.json under 'findings' and 'vulnSummary'
```

### Run Only Vulnerability Detection

```bash
# On existing parsed_trace.json
node scripts/vuln_detect.js --parsed parsed_trace.json --out findings.json

# Available options:
#   --parsed <path>    Path to parsed_trace.json (default: parsed_trace.json)
#   --trace <path>     Path to trace.json for additional context (optional)
#   --out <path>       Output file for findings (default: findings.json)
```

### Static Analysis (Optional)

#### Install Tools

```bash
# For Slither
pip install slither-analyzer

# For Mythril
pip install mythril
```

#### Run Static Analysis

```bash
# Run both Slither and Mythril
node scripts/static_scan.js --contracts ./contracts --out static_findings.json

# Skip Mythril (faster)
node scripts/static_scan.js --contracts ./contracts --skip-mythril --out static_findings.json

# Options:
#   --contracts <path>   Path to contracts directory (default: ./contracts)
#   --out <path>         Output file (default: static_findings.json)
#   --skip-mythril       Skip Mythril analysis
```

---

## Output Schema

### Dynamic Findings (findings.json)

```json
{
  "findings": [
    {
      "id": "VUL-0001",
      "rule": "reentrancy",
      "severity": "high",
      "title": "Potential Reentrancy: External Call Before State Update",
      "description": "External call at step X followed by state update at step Y...",
      "evidence": {
        "pattern": "state_update_after_external_call",
        "call_step": 42,
        "call_op": "CALL",
        "call_depth": 1,
        "sstore_step": 85,
        "sstore_depth": 1,
        "steps_between": 43
      },
      "recommendation": "Use checks-effects-interactions pattern..."
    }
  ],
  "summary": {
    "total": 1,
    "critical": 0,
    "high": 1,
    "medium": 0,
    "low": 0
  }
}
```

### Static Analysis Output (static_findings.json)

```json
{
  "findings": [
    {
      "id": "SLITHER-0001",
      "source": "slither",
      "rule": "reentrancy",
      "severity": "critical",
      "title": "reentrancy-eth",
      "description": "Contract is vulnerable to reentrancy attacks...",
      "evidence": {
        "check": "reentrancy-eth",
        "impact": "High",
        "confidence": "High"
      },
      "recommendation": "Review Slither findings..."
    }
  ],
  "summary": {
    "total": 5,
    "critical": 1,
    "high": 2,
    "medium": 2,
    "low": 0,
    "sources": {
      "slither": 3,
      "mythril": 2
    }
  }
}
```

### Embedded in Parsed Trace

When using `--embed-findings`, findings are added to `parsed_trace.json`:

```json
{
  "rows": [...],
  "topOps": [...],
  "findings": [
    { "id": "VUL-0001", ... }
  ],
  "vulnSummary": {
    "total": 1,
    "critical": 0,
    "high": 1,
    ...
  }
}
```

---

## Dashboard Display

The HTML dashboard (`dashboard.html`) automatically displays vulnerabilities if present:

1. **Vulnerabilities Panel** (top, left side)
   - Summary: Total and breakdown by severity
   - Color-coded findings by severity
   - Recommendation and metadata displayed

2. **Severity Colors**:
   - üî¥ **Critical** (dark red): #c23c2a
   - üü† **High** (orange): #d97706
   - üü° **Medium** (amber): #f59e0b
   - üü¢ **Low** (green): #10b981

3. **Auto-loading**:
   - Reads from `parsed_trace.json` if findings embedded
   - Falls back to `findings.json` if separate file exists
   - Shows "No vulnerabilities detected" if neither present

---

## Technical Details

### Heuristic Limitations & Edge Cases

All detection is **heuristic-based** and trace-dependent:

1. **Reentrancy**
   - Looks for state-write-after-call pattern
   - May miss: indirect reentrancy, cross-contract reentrancy not in same tx
   - Reduces false positives by checking depth consistency

2. **Unchecked Calls**
   - Looks for ISZERO/JUMPI/REVERT in next 20 steps
   - May miss: inline checks via assembly, complex conditionals
   - Window size (20 steps) is configurable in source

3. **Access Control**
   - ORIGIN usage is straightforward
   - DELEGATECALL flagged for review (not all are dangerous)
   - Recommend manual review

4. **Overflow/Underflow**
   - Solidity >=0.8 has built-in checks (Compiler handles it)
   - Trace shows REVERT/INVALID when checks trigger
   - For <0.8: static tools (Slither) recommended

### Combining Dynamic & Static Analysis

For production systems, **always use both**:

```bash
# 1. Dynamic analysis (trace-based, per-transaction)
node scripts/parse_trace.js --detect-vulns

# 2. Static analysis (code-based, whole contract)
node scripts/static_scan.js --contracts ./contracts
```

Then correlate findings manually:
- **High confidence**: Finding appears in both dynamic and static
- **Static only**: Pattern in code, not triggered in test transaction
- **Dynamic only**: Issue only manifests under specific conditions

---

## Examples

### Example 1: Reentrancy Detection

**Contract Code**:
```solidity
function withdraw(uint amount) public {
    require(balanceOf[msg.sender] >= amount);
    
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success);
    
    balanceOf[msg.sender] -= amount;  // State update after call!
}
```

**Trace Snippet**:
```
Step 42: CALL (depth: 1) - external call to msg.sender
Step 43-84: inline execution
Step 85: SSTORE - update balanceOf
```

**Detection Output**:
```json
{
  "id": "VUL-0001",
  "rule": "reentrancy",
  "severity": "high",
  "title": "Potential Reentrancy: External Call Before State Update",
  "evidence": {
    "call_step": 42,
    "sstore_step": 85,
    "steps_between": 43
  }
}
```

---

### Example 2: Unchecked Call

**Contract Code**:
```solidity
function executeCall(address target, bytes memory data) public {
    target.call(data);  // No return value check!
    doSomethingElse();
}
```

**Trace Snippet**:
```
Step 15: CALL
Step 16: operation
Step 17: operation
... (no ISZERO/JUMPI/REVERT in next 20 steps)
```

**Detection Output**:
```json
{
  "rule": "unchecked_call",
  "severity": "medium",
  "title": "Unchecked External Call: CALL",
  "evidence": {
    "call_step": 15,
    "checked_within_steps": 20,
    "found_check": false
  }
}
```

---

## Integration with CI/CD

### GitHub Actions Example

```yaml
- name: Analyze transaction trace
  run: |
    node scripts/trace.js
    node scripts/parse_trace.js --detect-vulns --embed-findings
    node scripts/static_scan.js --contracts ./contracts

- name: Fail if critical issues found
  run: |
    CRITICAL=$(jq '.summary.critical' findings.json)
    if [ "$CRITICAL" -gt 0 ]; then
      echo "‚ùå Critical vulnerabilities found!"
      exit 1
    fi
```

---

## Troubleshooting

### Issue: `vuln_detect.js` not found

**Solution**: Ensure you're running from workspace root:
```bash
node scripts/vuln_detect.js
# OR from project root:
node ./scripts/vuln_detect.js
```

### Issue: Slither/Mythril not found

**Solution**: Install tools

```bash
pip install slither-analyzer mythril
```

Verify installation:
```bash
slither --version
myth --version
```

### Issue: No findings generated

Possible causes:
1. Very simple contract with no detected issues
2. Transaction doesn't trigger vulnerable patterns
3. Check `findings.json` was created: `ls -la findings.json`

### Issue: High false positives

Recommendations:
1. Review evidence in findings to understand heuristic
2. Consider code context: not all DELEGATECALL are dangerous
3. Cross-check with Slither/Mythril static analysis
4. Manual review of source code

---

## Extending the Module

To add new detectors, edit `scripts/vuln_detect.js`:

```javascript
// Add method to VulnDetector class
detectMyVulnerability() {
  if (!this.parsed.rows) return;
  
  // Your detection logic
  const found = checkMyPattern();
  
  if (found) {
    this.addFinding(
      'my_rule',
      'medium',
      'Title',
      'Description',
      { evidence: '...' }
    );
  }
}

// Call in analyze() method
analyze() {
  this.detectReentrancy();
  this.detectUncheckedCalls();
  this.detectAccessControl();
  this.detectOverflow();
  this.detectMyVulnerability();  // Add here
  return this.findings;
}
```

---

## References

- **Reentrancy**: [OpenZeppelin Guards](https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard)
- **Slither**: [Trail of Bits](https://github.com/crytic/slither)
- **Mythril**: [ConsenSys](https://github.com/ConsenSys/mythril)
- **Hardhat**: [Hardhat Docs](https://hardhat.org/docs)
- **EVM Opcodes**: [ethereum.org](https://ethereum.org/en/developers/docs/evm/opcodes/)

---

## License

See main project README.
